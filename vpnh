#!/usr/bin/env ruby

require 'fileutils'
require 'logger'
require 'json'
require 'pp'
require 'pry'

require_relative 'Util.rb'

#--- BEG. Globals
$logger = Logger.new(STDOUT)
$the_path = File.join('/', 'var', 'opt', 'vpnh');
$pid_path = File.join($the_path, 'lock.pid');
$ipc_path = File.join($the_path, 'ipc.sock');
$con_path = File.join($the_path, 'config.json');
#--- END. Globals

#--- BEG. Helpers
def die_with_usage(msg=nil, ecode=1)
  puts "Usage: vpnh [command]"
  puts "\n#{msg}" if msg
  exit ecode
end
module Shared
  def self.running_server_pid
    return nil unless File.exists?($pid_path)
    existing_pid = IO.read($pid_path).strip.to_i
    if existing_pid && Util.process_exists?(existing_pid)
      return existing_pid
    end
    return nil
  end
end
#--- END. Helper

class ConfigFile

  def initialize(file_path)
    @file_path = file_path
    raise 'expecting file_path' unless @file_path
    @data_read = {}
    @data = {}
    data_read
    data_write if changed?
  end

  def get(key)
    @data[key.to_s]
  end

  def set(key, val)
    @data[key.to_s] = val
    data_write if changed?
  end

  def data_read
    return unless File.exists?(@file_path)
    gdata = {}
    odata = JSON.parse(IO.read(@file_path))
    odata.each do |k, v|
      next if k[0] == '_'
      gdata[k] = v
    end
    @data_read = gdata.clone
    @data = gdata.clone
  end

  def data_write
    $logger.info "VpnhConfig. data_write ..."
    dirname = File.dirname(@file_path)
    FileUtils.mkdir_p(dirname)
    data = @data.clone
    data['_write_ts'] = Time.now.to_i
    json_str = JSON.pretty_generate(data)
    IO.write(@file_path, json_str+"\n")
    data_read
  end

  def changed?
    @data_read != @data || !File.exists?(@file_path)
  end

end

class VpnhConfig

  def initialize(conthing)
    case conthing
    when String
      @config = ConfigFile.new(conthing)
    when ConfigFile
      @config = conthing
    else
      raise 'invalid conthing'
    end
  end

  def real_iface=(val)
    if val == nil
      @config.set(Util.get_default_iface)
      return
    end
    # TODO ensure that val is a valid iface
    @config.set(val)
  end

end

class VpnhMaster
  attr_reader :the_path

  def initialize
    @the_path = File.join('/', 'var', 'opt', 'vpnh')
    @config = VpnhConfig.new(con_path)
  end

  def config
    @config
  end

  def server
    @server ||= VpnhClient.new
  end

  def client
    @client ||= VpndServer.new
  end

  def pid_path
    @pid_path ||= File.join(@the_path, 'lock.pid');
  end

  def ipc_path
    @ipc_path ||= File.join(@the_path, 'ipc.sock');
  end

  def con_path
    @con_path ||= File.join(@the_path, 'config.json');
  end

end

class VpnhServer
  require 'drb'
  def initialize
    @mainloop_go = true
    @t1 = nil
  end

  def ignition
    if (existing_pid=Shared.running_server_pid)
      raise "Another VpnhServer is already running at PID=#{existing_pid}"
    end
    IO.write($pid_path, "#{Process.pid}\n")
    trap("TERM") do
      puts "\n--- Heard SIGTERM ---"
      shutdown
    end
    trap("INT") do
      puts "\n--- Heard SIGINT ---"
      shutdown
    end
    mainloop
  end

  def shutdown
    @mainloop_go = false
    pid = File.exists?($pid_path) ? IO.read($pid_path).strip.to_i : nil
    return unless pid
    return Process.kill(15, pid) unless pid == Process.pid
    FileUtils.rm_f($pid_path)
    DRb.stop_service
  end

  def status
    return {
      :state => :running
    }
  end

  def time
    return Time.now
  end

  def t1_kill
    return unless @t1
    $logger.info "killing t1..."
    Thread.kill(@t1)
  end

  def get_default_iface
    Util.get_default_iface
  end

  private
  
  def mainloop
    FileUtils.rm_f($ipc_path) if File.exists?($ipc_path)
    DRb.start_service("drbunix://#{$ipc_path}", self)
    @t1 = Thread.new {
      while(@mainloop_go)
        $logger.info "."
        sleep 2
      end
    }
    begin
    DRb.thread.join
    rescue
    ensure
      DRb.stop_service
    end
    shutdown
  end
end

# mainly delegates to the VpnhServer object
# via DRb. Ensures that the VpnhServer remote
# object is connected.
class VpnhClient
  require 'drb'

  def initialize
    @server = nil
  end

  def method_missing(meth, *args, &block)
    connect
    if @server && @server.respond_to?(meth)
      @server.public_send(meth, *args, &block)
    end
  end

  def status
    connect
    return {
      :state => :not_running
    } unless @server
    return @server.status
  end

  private

  def connect
    return if @server
    if Shared.running_server_pid && File.exists?($ipc_path)
      @server = DRbObject.new_with_uri("drbunix://#{$ipc_path}")
    end
  end
end

#--- MAIN
die_with_usage("only root can run vpnh") unless Util.ami_root?
FileUtils.mkdir_p($the_path)

command = ARGV.join(" ").chomp
unless command && command.size > 0 
  die_with_usage
end

if command == 'help' || command == 'h'
  die_with_usage(nil, 0)
end

vpnc = VpnhClient.new

if command == 'server'
  vpnd = VpnhServer.new
  vpnd.ignition
elsif command == 'server daemon'
  Util.daemonize do
    vpnd = VpnhServer.new
    vpnd.ignition
  end
elsif command == 'server shutdown' || command == 'server stop' || command == 'stop'
  puts 'stopping vpnh server...'
  vpnc.shutdown
  puts 'stopping vpnh server... DONE'
elsif command == 'status'
  puts JSON.pretty_generate(vpnc.status)
elsif command =~ /^ovpnup(.*)$/
  args = $1.strip.split(/\s+/)
  puts "args=#{args}"
  unless args.size === 6
    die_with_usage('expecting 6 arguments from openvpn')
  end
  vpni_name = args[0]
  vpni_addr = args[3]
  vpni_mask = args[4]
  puts "vpni_name=#{vpni_name}"
  puts "vpni_addr=#{vpni_addr}"
  puts "vpni_mask=#{vpni_mask}"
elsif command == 'get_default_iface'
  puts Util.get_default_iface
elsif command =~ /x (\w+)/
  out = vpnc.public_send($1)
  puts out if out
else
  die_with_usage
end
