#!/usr/bin/env ruby

require 'fileutils'
require 'logger'
require 'drb'
require 'json'
require 'pp'

#--- Globals
$logger = Logger.new(STDOUT)
$the_path = File.join('/', 'var', 'opt', 'vpnh');
$pid_path = File.join($the_path, 'lock.pid');
$ipc_path = File.join($the_path, 'ipc.sock');
$con_path = File.join($the_path, 'config.json');

#--- Helpers
def die_with_usage(msg=nil, ecode=1)
  puts "Usage: vpnh [command]"
  puts "\n#{msg}" if msg
  exit ecode
end

module Util

  def self.ami_root?
    Process.euid == 0
  end

  def self.get_default_iface
    `netstat -r`.split("\n").each do |line|
      next unless line =~ /^default\b/
      return (line.split(/\s+/)[7].chomp)
    end
    return nil
  end

  def self.daemonize
    raise 'fork failed' if (pid=fork) == -1
    exit if pid != nil # exit the parent process
    Process.setsid # child becomes new session and group leader
    raise 'second fork failed' if (pid=fork) == -1
    exit if pid != nil
    daemon_pid = pid
    Dir.chdir '/'
    File.umask 0000
    STDIN.reopen '/dev/null'
    STDOUT.reopen '/dev/null'
    STDERR.reopen '/dev/null'
    yield
  end
  
  def self.process_exists?(pid)
    !!Process.kill(0, pid) rescue false
  end

end

class VpnhConfig

  def initialize(file_path)
    @file_path = file_path
    unless @file_path
      raise 'expecting file_path'
    end
    @data = {}
    @data_read = {}
    sync
  end

  def sync
    read
    fix
    write if changed?
  end
  
  def read
    return unless File.exists?(@file_path)
    gdata = {}
    odata = JSON.parse(IO.read(@file_path))
    odata.each do |k, v|
      return if k[0] == '_'
      gdata[k] = v
    end
    @data_read = gdata.clone
    @data = gdata.clone
  end

  def fix
    unless @data['real_iface']
      @data['real_iface'] = Util.get_default_iface
    end
  end

  def write
    dirname = File.dirname(@file_path)
    FileUtils.mkdir_p(dirname)
    data = @data.clone
    data['_write_ts'] = Time.now.to_i
    json_str = JSON.pretty_generate(data)
    IO.write(@file_path, json_str+"\n")
    read
  end

  def changed?
    !File.exists?(@file_path) || @data_read != @data
  end

end

module Shared
  def self.running_server_pid
    return nil unless File.exists?($pid_path)
    existing_pid = IO.read($pid_path).strip.to_i
    if existing_pid && Util.process_exists?(existing_pid)
      return existing_pid
    end
    return nil
  end
end

class VpnhServer

  def initialize
    @mainloop_go = true
    @vcon = VpnhConfig.new($con_path)
    @t1 = nil
  end

  def ignition
    if (existing_pid=Shared.running_server_pid)
      raise "Another VpnhServer is already running at PID=#{existing_pid}"
    end
    IO.write($pid_path, "#{Process.pid}\n")
    trap("TERM") do
      puts "\n--- Heard SIGTERM ---"
      shutdown
    end
    trap("INT") do
      puts "\n--- Heard SIGINT ---"
      shutdown
    end
    mainloop
  end

  def shutdown
    @mainloop_go = false
    pid = File.exists?($pid_path) ? IO.read($pid_path).strip.to_i : nil
    return unless pid
    return Process.kill(15, pid) unless pid == Process.pid
    FileUtils.rm_f($pid_path)
    DRb.stop_service
  end

  def status
    return {
      :state => :running
    }
  end

  def time
    return Time.now
  end

  def t1_kill
    return unless @t1
    $logger.info "killing t1..."
    Thread.kill(@t1)
  end

  def get_default_iface
    Util.get_default_iface
  end

  private
  
  def mainloop
    FileUtils.rm_f($ipc_path) if File.exists?($ipc_path)
    DRb.start_service("drbunix://#{$ipc_path}", self)
    @t1 = Thread.new {
      while(@mainloop_go)
        $logger.info "."
        sleep 2
      end
    }
    begin
    DRb.thread.join
    rescue
    ensure
      DRb.stop_service
    end
    shutdown
  end
end

# mainly delegates to the VpnhServer object
# via DRb. Ensures that the VpnhServer remote
# object is connected.
class VpnhClient
  def initialize
    @server = nil
  end

  def method_missing(meth, *args, &block)
    connect
    if @server && @server.respond_to?(meth)
      @server.public_send(meth, *args, &block)
    end
  end

  def status
    connect
    return {
      :state => :not_running
    } unless @server
    return @server.status
  end

  private

  def connect
    return if @server
    if Shared.running_server_pid && File.exists?($ipc_path)
      @server = DRbObject.new_with_uri("drbunix://#{$ipc_path}")
    end
  end
end

#--- MAIN
die_with_usage("only root can run vpnh") unless Util.ami_root?
FileUtils.mkdir_p($the_path)

command = ARGV.join(" ").chomp
unless command && command.size > 0 
  die_with_usage
end

if command == 'help' || command == 'h'
  die_with_usage(nil, 0)
end

vpnc = VpnhClient.new

if command == 'server'
  vpnd = VpnhServer.new
  vpnd.ignition
elsif command == 'server daemon'
  Util.daemonize do
    vpnd = VpnhServer.new
    vpnd.ignition
  end
elsif command == 'server shutdown' || command == 'server stop' || command == 'stop'
  puts 'stopping vpnh server...'
  vpnc.shutdown
  puts 'stopping vpnh server... DONE'
elsif command == 'status'
  puts JSON.pretty_generate(vpnc.status)
elsif command =~ /config set file\b(.+)/
  file_path = $1.strip
  unless File.exists?(file_path)
    puts "expecting file at #{file_path}"
    exit 1
  end
  file_data = JSON.parse(IO.read(file_path))
  pp file_data
  config_real_iface = file_data['real_iface']
  if config_real_iface == '_X_DEFAULT'
    config_real_iface = Util.get_default_iface
  end
  errors = []
  unless config_real_iface
    errors.push('expecting config.real_iface')
  end
  if errors.size > 0
    puts "config file has errors:"
    errors.each do |err|
      puts "* #{err}"
    end
    puts
    exit 1
  end
elsif command =~ /^ovpnup(.*)$/
  args = $1.strip.split(/\s+/)
  puts "args=#{args}"
  unless args.size === 6
    die_with_usage('expecting 6 arguments from openvpn')
  end
  vpni_name = args[0]
  vpni_addr = args[3]
  vpni_mask = args[4]
  puts "vpni_name=#{vpni_name}"
  puts "vpni_addr=#{vpni_addr}"
  puts "vpni_mask=#{vpni_mask}"
elsif command == 'get_default_iface'
  puts Util.get_default_iface
elsif command =~ /x (\w+)/
  out = vpnc.public_send($1)
  puts out if out
else
  die_with_usage
end
